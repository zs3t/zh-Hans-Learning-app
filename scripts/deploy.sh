#!/bin/bash

# ==============================================================================
# Hanzi App - 生产环境一键部署脚本
# 运行方式:
#   1. 首次部署: 在服务器上任意位置执行此脚本。它会克隆仓库并设置项目。
#      例如: bash /path/to/your/repo/scripts/deploy.sh
#   2. 后续更新: 在项目根目录内执行 'bash scripts/deploy.sh' 或直接在 /scripts 目录执行。
#      例如: cd zh-Hans-Learning-app && bash scripts/deploy.sh
# ==============================================================================

# -- 配置 (请根据你的服务器环境修改) --
APP_NAME="zh-Hans-Learning-app"
GIT_REPO_URL="https://github.com/zs3t/zh-Hans-Learning-app.git" # Git 仓库地址
# DEST_BASE_DIR: 项目将被部署到的父目录。例如，项目将在 /var/www/zh-Hans-Learning-app
# 或者 /home/deploy-user/zh-Hans-Learning-app。
# **推荐设置为当前用户可以写入的路径，例如 /home/$(whoami) 或 /var/www**
DEST_BASE_DIR="/$(whoami)" # 默认为当前用户的主目录，通常是 /home/youruser 或 /root

# PROJECT_DIR 将会被脚本动态确定，它会是 $DEST_BASE_DIR/$APP_NAME

# -- 脚本开始 --
set -e # 遇到错误立即退出，提高脚本的健壮性
set -x # 调试模式：打印执行的每一个命令，有助于排查问题。如果不需要调试，请注释掉

echo "🚀 开始部署 '$APP_NAME'..."

# --- 确定项目根目录 ---
# 1. 首先尝试从当前脚本的路径推断项目根目录
SCRIPT_DIR="$(dirname "$(realpath "$0")")" # 获取脚本本身所在的目录 (例如 /home/user/app/scripts)
POTENTIAL_PROJECT_DIR="$(dirname "$SCRIPT_DIR")"

# 检查 POTENTIAL_PROJECT_DIR 是否是已存在的 Git 仓库或者包含 package.json
if [ -d "$POTENTIAL_PROJECT_DIR/.git" ] && [ -f "$POTENTIAL_PROJECT_DIR/package.json" ]; then
    PROJECT_DIR="$POTENTIAL_PROJECT_DIR"
    echo "✅ 项目目录已通过脚本路径推断为: $PROJECT_DIR"
else
    # 2. 如果无法推断，则认为是首次部署，或者脚本在项目外部运行
    #    此时，项目目录将由 DEST_BASE_DIR 和 APP_NAME 组合而成
    PROJECT_DIR="$DEST_BASE_DIR/$APP_NAME"
    echo "🤔 无法通过脚本路径推断项目目录。将使用默认部署路径: $PROJECT_DIR"
fi


# 1. 检查 PM2 是否安装
if ! command -v pm2 &> /dev/null
then
    echo "PM2 未安装。正在全局安装 PM2..."
    npm install pm2 -g || { echo "❌ 错误: 安装 PM2 失败。请检查 npm 或用户权限。"; exit 1; }
    echo "✅ PM2 安装成功。"
fi

# 2. 准备项目目录并更新代码
if [ ! -d "$PROJECT_DIR" ]; then
    echo "项目目录 '$PROJECT_DIR' 不存在。正在创建父目录并从 Git 克隆..."
    # 确保父目录存在且当前用户有权限
    mkdir -p "$DEST_BASE_DIR" || { echo "❌ 错误: 创建目标基目录 '$DEST_BASE_DIR' 失败。请检查目录权限。"; exit 1; }

    # 克隆仓库
    git clone "$GIT_REPO_URL" "$PROJECT_DIR" || { echo "❌ 错误: 从 Git 克隆失败。请检查 Git 配置和网络连接。"; exit 1; }
    echo "✅ 仓库克隆成功到 '$PROJECT_DIR'。"
else
    echo "进入项目目录: $PROJECT_DIR"
fi
cd "$PROJECT_DIR" || { echo "❌ 错误: 无法进入项目目录 '$PROJECT_DIR'。"; exit 1; }

echo "正在从 Git 拉取最新代码..."
git fetch # 先获取最新变更
git reset --hard origin/main # 强制重置到远程 main 分支，确保本地与远程完全一致 (或者 origin/master)
echo "✅ 代码已更新到最新版本。"


# 3. 自动创建/验证 .env.production 文件
ENV_FILE=".env.production"
if [ ! -f "$ENV_FILE" ]; then
    echo "生产环境配置文件 '$ENV_FILE' 不存在，正在创建..."
    # 使用 `cat <<EOF > "$ENV_FILE"` 而不是 `tee`，更直接地创建文件
    cat <<EOF > "$ENV_FILE"
# Auto-generated by deploy.sh for production environment
DATABASE_URL="file:./prod.db" # SQLite 数据库文件的路径
NEXT_TELEMETRY_DISABLED=1    # 禁用 Next.js 遥测
# 其他你可能需要的生产环境变量，例如：
# NODE_ENV="production"
# PORT=3000
# SECRET_KEY="your_super_secret_key"
EOF
    echo "✅ '$ENV_FILE' 创建成功。"
else
    echo "✅ '$ENV_FILE' 文件已存在。"
fi

# ==============================================================================
# 解决 DATABASE_URL 问题的核心：加载 .env.production 文件
# ==============================================================================
echo "加载生产环境变量文件 '$ENV_FILE'..."
set -a # 自动导出后续定义的变量到子进程环境
source "$ENV_FILE" # 在当前 shell 中加载环境变量
set +a # 关闭自动导出
echo "✅ 环境变量已加载。"

# 4. 安装/更新 Node.js 生产依赖
echo "📦 安装 npm 生产依赖..."
# 建议在生产环境使用 npm ci，以确保 package-lock.json 和 node_modules 严格一致
# npm ci --production || { echo "❌ 错误: npm ci 失败。"; exit 1; }
npm install --production || { echo "❌ 错误: npm install 失败。"; exit 1; }
echo "✅ Node.js 依赖安装/更新成功。"

# 5. 应用数据库迁移
echo "🗄️ 应用 Prisma 数据库迁移..."
# 此处因为 ENV_FILE 已被加载， DATABASE_URL 应该可用
npx prisma migrate deploy || { echo "❌ 错误: Prisma 迁移失败。请检查 SCHEMA 和 DATABASE_URL。"; exit 1; }
echo "✅ Prisma 数据库迁移成功。"

# 6. 构建 Next.js 应用
echo "🏗️  正在构建 Next.js 应用..."
npm run build || { echo "❌ 错误: Next.js 构建失败。"; exit 1; }
echo "✅ Next.js 应用构建成功。"

# 7. 使用 PM2 启动或重启应用
echo "🔄 使用 PM2 启动/重启应用..."
# 对于 Next.js 应用，PM2 建议使用 `next start` 或 `npm run start` 命令。
# 确保你的 package.json 中 'start' 脚本是 `next start`
if pm2 list | grep -q "$APP_NAME"; then
    echo "应用 '$APP_NAME' 已存在，正在执行 PM2 重载..."
    pm2 reload "$APP_NAME" --exp-backoff-restart-delay=100 || { echo "❌ 错误: PM2 重启失败。"; exit 1; }
else
    echo "应用 '$APP_NAME' 首次部署，正在执行 PM2 启动..."
    # 使用 npm run start 因为它通常会调用 next start 并且更通用
    pm2 start npm --name "$APP_NAME" -- run start || { echo "❌ 错误: PM2 启动失败。"; exit 1; }
fi
echo "✅ PM2 启动/重启命令执行完成。"

# 8. 保存 PM2 进程列表，以便服务器重启后自动恢复
echo "💾 保存 PM2 进程列表..."
pm2 save || { echo "❌ 错误: PM2 保存进程列表失败。"; exit 1; }
echo "✅ PM2 进程列表已保存。"

echo ""
echo "🎉 部署完成！"
echo "   应用 '$APP_NAME' 正在运行中。"
echo "   使用 'pm2 list' 查看状态。"
echo "   使用 'pm2 logs $APP_NAME' 查看实时日志。"
echo "   访问你的应用程序: http://你的服务器IP或域名:3000 (如果 Next.js 默认端口是 3000)"
