#!/bin/bash

# ==============================================================================
# Hanzi App - 生产环境一键部署脚本
# 运行方式:
#   1. 首次部署: 在服务器上任意位置执行此脚本。它会克隆仓库并设置项目。
#      例如: bash /path/to/your/repo/scripts/deploy.sh
#   2. 后续更新: 在项目根目录内执行 'bash scripts/deploy.sh' 或直接在 /scripts 目录执行。
#      例如: cd /home/your-user/zh-hans-learning-app && bash scripts/deploy.sh
# ==============================================================================

# -- 配置 (请根据你的服务器环境修改) --
APP_NAME="zh-hans-learning-app"
GIT_REPO_URL="git@github.com:zs3t/zh-hans-learning-app.git" # 你的 Git 仓库地址 (建议使用 SSH 地址)
# DEST_BASE_DIR: 项目将被部署到的父目录。例如，项目将在 /var/www/zh-hans-learning-app
# 或者 /home/deploy-user/zh-hans-learning-app。
# 这样每个用户或环境可以自定义这个基础目录。
DEST_BASE_DIR="/home/$(whoami)" # 默认将项目部署到当前用户的主目录

# PROJECT_DIR 将会被脚本动态确定，它会是 $DEST_BASE_DIR/$APP_NAME

# -- 脚本开始 --
set -e # 遇到错误立即退出

echo "🚀 开始部署 '$APP_NAME'..."

# --- 确定项目根目录 ---
# 1. 首先尝试从当前脚本的路径推断项目根目录
#    如果脚本在项目根目录下的 scripts 子目录中，那么项目根目录就是 scripts 的父目录
SCRIPT_DIR="$(dirname "$(realpath "$0")")" # 获取脚本本身所在的目录 (例如 /home/user/app/scripts)
# 尝试向上追踪一层，看看是否是项目根目录
POTENTIAL_PROJECT_DIR="$(dirname "$SCRIPT_DIR")"

# 检查 POTENTIAL_PROJECT_DIR 是否是已存在的 Git 仓库或者包含 package.json
if [ -d "$POTENTIAL_PROJECT_DIR/.git" ] && [ -f "$POTENTIAL_PROJECT_DIR/package.json" ]; then
    PROJECT_DIR="$POTENTIAL_PROJECT_DIR"
    echo "✅ 项目目录已通过脚本路径推断为: $PROJECT_DIR"
else
    # 2. 如果无法推断，则认为是首次部署，或者脚本在项目外部运行
    #    此时，项目目录将由 DEST_BASE_DIR 和 APP_NAME 组合而成
    PROJECT_DIR="$DEST_BASE_DIR/$APP_NAME"
    echo "🤔 无法通过脚本路径推断项目目录。将使用默认部署路径: $PROJECT_DIR"
fi


# 1. 检查 PM2 是否安装
if ! command -v pm2 &> /dev/null
then
    echo "PM2 未安装。正在全局安装 PM2..."
    npm install pm2 -g || { echo "❌ 错误: 安装 PM2 失败。"; exit 1; }
fi

# 2. 准备项目目录并更新代码
# 如果目录不存在，则从 Git 克隆
if [ ! -d "$PROJECT_DIR" ]; then
    echo "项目目录 '$PROJECT_DIR' 不存在。正在创建父目录并从 Git 克隆..."
    # 确保父目录存在
    sudo mkdir -p "$DEST_BASE_DIR" || { echo "❌ 错误: 创建目标基目录 '$DEST_BASE_DIR' 失败。"; exit 1; }
    # 克隆前需要确保权限，或者克隆到用户可写的目录下
    git clone "$GIT_REPO_URL" "$PROJECT_DIR" || { echo "❌ 错误: 从 Git 克隆失败。"; exit 1; }
    cd "$PROJECT_DIR" || { echo "❌ 错误: 无法进入项目目录 '$PROJECT_DIR'。"; exit 1; }
else
    echo "进入项目目录: $PROJECT_DIR"
    cd "$PROJECT_DIR" || { echo "❌ 错误: 无法进入项目目录 '$PROJECT_DIR'。"; exit 1; }
    echo "正在从 Git 拉取最新代码..."
    git pull || { echo "❌ 错误: Git pull 失败。"; exit 1; }
fi

# 3. 自动创建/验证 .env.production 文件
ENV_FILE=".env.production"
if [ ! -f "$ENV_FILE" ]; then
    echo "生产环境配置文件 '$ENV_FILE' 不存在，正在创建..."
    tee "$ENV_FILE" > /dev/null <<EOF
# Auto-generated by deploy.sh
DATABASE_URL="file:./prod.db"
NEXT_TELEMETRY_DISABLED=1
EOF
    echo "✅ '$ENV_FILE' 创建成功。"
else
    echo "✅ '$ENV_FILE' 文件已存在。"
fi

# 4. 安装/更新 Node.js 生产依赖
echo "📦 安装 npm 生产依赖..."
npm install --production || { echo "❌ 错误: npm install 失败。"; exit 1; }

# 5. 应用数据库迁移
echo "🗄️ 应用 Prisma 数据库迁移..."
npx prisma migrate deploy || { echo "❌ 错误: Prisma 迁移失败。"; exit 1; }

# 6. 构建 Next.js 应用
echo "🏗️  正在构建 Next.js 应用..."
npm run build || { echo "❌ 错误: 构建失败。"; exit 1; }

# 7. 使用 PM2 启动或重启应用
echo "🔄 使用 PM2 启动/重启应用..."
if pm2 list | grep -q "$APP_NAME"; then
    pm2 reload "$APP_NAME" --exp-backoff-restart-delay=100 || { echo "❌ 错误: PM2 重启失败。"; exit 1; }
else
    # 第一次启动
    pm2 start npm --name "$APP_NAME" -- start || { echo "❌ 错误: PM2 启动失败。"; exit 1; }
fi

# 保存 PM2 进程列表，以便服务器重启后自动恢复
pm2 save || { echo "❌ 错误: PM2 保存进程列表失败。"; exit 1; }

echo ""
echo "🎉 部署完成！"
echo "   应用 '$APP_NAME' 正在运行中。"
echo "   使用 'pm2 list' 查看状态。"
echo "   使用 'pm2 logs $APP_NAME' 查看实时日志。"
